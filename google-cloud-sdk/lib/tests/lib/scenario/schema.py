# -*- coding: utf-8 -*- #
# Copyright 2017 Google LLC. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Parses the scenario yaml test file."""

from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals

import abc
import io
import os
import shutil
import sys


from googlecloudsdk.calliope import base as calliope_base
from googlecloudsdk.core import execution_utils
from googlecloudsdk.core import log
from googlecloudsdk.core import properties
from googlecloudsdk.core import yaml
from googlecloudsdk.core.util import files
from googlecloudsdk.core.util import pkg_resources
from googlecloudsdk.core.util import retry
from tests.lib import e2e_utils
from tests.lib import sdk_test_base
from tests.lib.scenario import assertions
from tests.lib.scenario import events
from tests.lib.scenario import reference_resolver
from tests.lib.scenario import session
from tests.lib.scenario import updates

import jsonschema
import six


_SCENARIO_SCHEMA_FILE_NAME = 'scenario_schema.yaml'
_SCENARIO_SCHEMA_PATH = (os.path.join(os.path.dirname(__file__),
                                      _SCENARIO_SCHEMA_FILE_NAME))


class Error(Exception):
  """Base exception for the module."""
  pass


class ValidationError(Error):
  """Exception for when schema validation fails."""
  pass


class ScenarioContext(object):
  """A holder for things from a test_base that the scenario needs to run.

  Attributes:
    spec_name: str, A human friendly name that clearly indicates what scenario
      is being operated on.
    full_spec_path: str, The absolute path to the file that the spec was loaded
      from.
    spec_data: The parsed spec data.
    track: calliope_base.ReleaseTrack, Release track to run the test in.
    execution_mode: session.ExecutionMode, The mode the tests are running in.
    update_modes: [updates.Mode], The list of enabled update modes for this
      scenario run.
    stream_mocker: session.StreamMocker, The holder for mock streams to event
      handling.
    command_executor: f([str]), The function to call to execute a command.
    resource_ref_resolver: ResourceReferenceResolver, The resolver used to
      resolve resource references in the scenario file (ex. $$my-instance$$)
      with the actual resource ID generated by a generate_resource_id action.
    debug: True to print extra debugging information during testing.
  """

  def __init__(self, spec_name, full_spec_path, spec_data, track,
               execution_mode, update_modes, stream_mocker, command_executor,
               debug=False):
    self.spec_name = spec_name
    self.full_spec_path = full_spec_path
    self.spec_data = spec_data
    self.track = track
    self.execution_mode = execution_mode
    self.update_modes = update_modes
    self.stream_mocker = stream_mocker
    self.command_executor = command_executor
    self.resource_ref_resolver = reference_resolver.ResourceReferenceResolver()
    self.debug = debug

  def RewriteScenario(self):
    with io.open(self.full_spec_path, 'wt') as f:
      yaml.dump(self.spec_data, f, round_trip=True)


class Scenario(object):
  """Holds the entire scenario spec."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""

    return cls(
        title=data.get('title'),
        description=data.get('description'),
        filters=data.get('filters'),
        data=data)

  def __init__(self, title, description, filters, data):
    self.title = title
    self.description = description
    self.filters = filters
    self._data = data

  def LoadActions(self):
    """A generator that loads each action in the scenario when needed."""
    for a in self._data.get('actions') or []:
      if 'set_property' in a:
        yield SetPropertyAction.FromData(a)
      elif 'write_file' in a:
        yield WriteFileAction.FromData(a)
      elif 'load_resource' in a:
        yield LoadResourceAction.FromData(a)
      elif 'generate_resource_id' in a:
        yield GenerateResourceIdAction.FromData(a)
      elif 'define_reference' in a:
        yield DefineReferenceAction.FromData(a)
      elif 'execute_command_until' in a:
        yield ExecuteCommandUntilAction.FromData(a)
      elif 'execute_binary' in a:
        yield ExecuteBinaryAction.FromData(a)
      elif 'execute_command' in a:
        yield ExecuteCommandAction.FromData(a)
      else:
        # This will never happen if schema passes validation.
        raise ValueError('Unknown action type: {}'.format(a))

  def UpdateSummary(self, scenario_context):
    """Generates and updates the summary for the entire scenario run."""
    steps = []
    for a in self.LoadActions():
      steps.extend(a.Summary())
    yaml.convert_to_block_text(steps)

    if 'summary' in self._data:
      del self._data['summary']
    # Only add the summary if it's non-empty; otherwise ruamel messes up the
    # subsequent indentation when inserting a comment after an empty list.
    if steps:
      self._data.insert(len(self._data) - 1, 'summary', steps)
      self._data.yaml_set_comment_before_after_key(
          'summary',
          after='This summary is generated by http://go/gcloud-scenario-tests on update and should '
                'not be edited.',
          after_indent=0)
    scenario_context.RewriteScenario()


class Action(six.with_metaclass(abc.ABCMeta, object)):
  """Base class for all actions."""

  def Summary(self):
    return []

  @abc.abstractmethod
  def Execute(self, scenario_context):
    pass

  def ExecuteCleanup(self, scenario_context):
    return None


class SetPropertyAction(Action):
  """Action that sets properties."""

  @classmethod
  def FromData(cls, data):
    return cls(data.get('set_property', {}))

  def __init__(self, props):
    super(SetPropertyAction, self).__init__()
    self.properties = props

  def Summary(self):
    return [{'set_property': '{} {}'.format(p, v)}
            for p, v in six.iteritems(self.properties)]

  def Execute(self, scenario_context):
    del scenario_context
    for p, v in six.iteritems(self.properties):
      properties.FromString(p).Set(v)


class WriteFileAction(Action):
  """Action that writes a file for use in tests."""

  @classmethod
  def FromData(cls, data):
    write_file_data = data['write_file']
    path = write_file_data['path']
    contents = write_file_data.get('contents')
    binary_contents = write_file_data.get('binary_contents')
    if (binary_contents is not None and
        isinstance(binary_contents, six.text_type)):
      binary_contents = binary_contents.encode('utf-8')

    return cls(path, contents, binary_contents)

  def __init__(self, path, contents, binary_contents):
    super(WriteFileAction, self).__init__()
    self._path = path
    self._contents = contents
    self._binary_contents = binary_contents

  def Execute(self, scenario_context):
    full_path = os.path.join(os.getcwd(), self._path)
    files.MakeDir(os.path.dirname(full_path))
    if self._binary_contents:
      files.WriteBinaryFileContents(full_path, self._binary_contents)
    else:
      rrr = scenario_context.resource_ref_resolver
      files.WriteFileContents(full_path, rrr.Resolve(self._contents))


class LoadResourceAction(Action):
  """Loads a resource from text data into the CWD for use in a test."""

  @classmethod
  def FromData(cls, data):
    path = data['load_resource']['path']
    return cls(path)

  def __init__(self, path):
    super(LoadResourceAction, self).__init__()
    self._path = path

  def Execute(self, scenario_context):
    del scenario_context
    resource_path = sdk_test_base.SdkBase.Resource(*self._path.split('/'))
    dest_path = os.path.join(os.getcwd(), os.path.basename(resource_path))
    if os.path.isdir(resource_path):
      files.CopyTree(resource_path, dest_path)
    else:
      shutil.copy(resource_path, dest_path)


class GenerateResourceIdAction(Action):
  """Action that generates a unique resource id for use in an e2e test."""

  @classmethod
  def FromData(cls, data):
    action_data = data['generate_resource_id']
    return cls(action_data['reference'], action_data['prefix'],
               action_data.get('requires_cleanup', True),
               action_data.get('delimiter', '-'))

  def __init__(self, reference, prefix, requires_cleanup, delimiter):
    super(GenerateResourceIdAction, self).__init__()
    self._reference = reference
    self._prefix = prefix
    self._requires_cleanup = requires_cleanup
    self.delimiter = delimiter

  def Execute(self, scenario_context):
    scenario_context.resource_ref_resolver.AddGeneratedResourceId(
        self._reference,
        next(e2e_utils.GetResourceNameGenerator(prefix=self._prefix,
                                                delimiter=self.delimiter)),
        requires_cleanup=self._requires_cleanup)


class DefineReferenceAction(Action):
  """Action that generates a reference that can be used for substitutions."""

  @classmethod
  def FromData(cls, data):
    action_data = data['define_reference']
    return cls(
        action_data['reference'],
        action_data.get('value'),
        {calliope_base.ReleaseTrack.FromId(t): v
         for t, v in action_data.get('track_values', {}).items()})

  def __init__(self, reference, value, track_values):
    super(DefineReferenceAction, self).__init__()
    self._reference = reference
    self._value = value
    self._track_values = track_values

  def Execute(self, scenario_context):
    value = self._track_values.get(scenario_context.track)
    if value is None:
      value = self._value
    if value is not None:
      scenario_context.resource_ref_resolver.SetReference(
          self._reference, value)


class ExecuteCommandUntilAction(Action):
  """Action that runs a command until all conditions are true."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""
    command_execution_data = data.get('execute_command_until')
    return cls(
        command_execution_data['command'],
        command_execution_data.get('track'),
        command_execution_data.get('retries'),
        command_execution_data.get('timeout', 120),
        command_execution_data.get('exit_code'),
        command_execution_data.get('stdout'),
        command_execution_data.get('stderr'),
        command_execution_data.get('exponential_sleep_multiplier', None),
        command_execution_data.get('wait_ceiling', None)
    )

  def __init__(self,
               command,
               track,
               retries,
               timeout,
               exit_code,
               stdout,
               stderr,
               exponential_sleep_multiplier,
               wait_ceiling):
    super(ExecuteCommandUntilAction, self).__init__()
    self._command = command
    self._track = calliope_base.ReleaseTrack.FromId(track) if track else None
    self._retries = retries
    self._timeout = timeout
    self._exit_code = exit_code
    self._stdout = stdout
    self._stderr = stderr
    self._exponential_sleep_multiplier = None
    self._wait_ceiling_ms = None

    if exponential_sleep_multiplier:
      self._exponential_sleep_multiplier = float(exponential_sleep_multiplier)
    if wait_ceiling:
      self._wait_ceiling_ms = wait_ceiling * 1000

  def Execute(self, scenario_context):
    if scenario_context.execution_mode == session.ExecutionMode.LOCAL:
      # No need to wait for anything in local mode.
      return

    rrr = scenario_context.resource_ref_resolver
    command = rrr.Resolve(self._command)
    exit_code_assertion = (
        None if self._exit_code is None
        else assertions.EqualsAssertion(self._exit_code))
    stdout_assertion = (
        None if self._stdout is None
        else assertions.Assertion.ForComplex(rrr.Resolve(self._stdout)))
    stderr_assertion = (
        None if self._stderr is None
        else assertions.Assertion.ForComplex(rrr.Resolve(self._stderr)))

    def _Run():
      """Executes the command for the retrier."""
      try:
        scenario_context.command_executor(command, track=self._track)
        exit_code = 0
      except Exception as e:  # pylint: disable=broad-except
        if isinstance(e, (KeyboardInterrupt, SystemExit)):
          raise
        exit_code = getattr(e, 'exit_code', 1)
      stdout = scenario_context.stream_mocker.stdout_reader()
      stderr = scenario_context.stream_mocker.stderr_reader()
      result = (exit_code, stdout, stderr)
      if scenario_context.debug:
        sys.__stderr__.write(
            'execute_command_until: Result: ' + six.text_type(result) + '\n')
      return result

    context = updates.Context.Empty()
    def _ShouldRetry(result, state):
      del state
      exit_code, stdout, stderr = result
      if exit_code_assertion and exit_code_assertion.Check(context, exit_code):
        return True
      if stdout_assertion and stdout_assertion.Check(context, stdout):
        return True
      if stderr_assertion and stderr_assertion.Check(context, stderr):
        return True
      return False

    retrier = retry.Retryer(max_retrials=self._retries,
                            max_wait_ms=self._timeout*1000,
                            exponential_sleep_multiplier=
                            self._exponential_sleep_multiplier,
                            wait_ceiling_ms=self._wait_ceiling_ms)
    retrier.RetryOnResult(_Run, should_retry_if=_ShouldRetry, sleep_ms=1000)


class ExecuteBinaryAction(Action):
  """Action that runs a non-gcloud binary."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""
    command_execution_data = data.get('execute_binary')
    return cls(
        command_execution_data['args'],
        command_execution_data.get('timeout', 60),
        command_execution_data.get('stdin'),
        command_execution_data,
    )

  def __init__(self, args, timeout, stdin, original_data):
    super(ExecuteBinaryAction, self).__init__()
    self._args = args
    self._timeout = timeout
    self._stdin = stdin
    self._original_data = original_data

  def Summary(self):
    return [{'execute_binary': ' '.join(self._args)}]

  def Execute(self, scenario_context):
    original_data = scenario_context.resource_ref_resolver.Resolve(
        self._original_data)
    original_data.setdefault('expect_exit', {})
    exit_event = events.ExitEvent.FromData(original_data)
    stdout_event = events.StdoutEvent.FromData(original_data)
    stderr_event = events.StderrEvent.FromData(original_data)

    stdout = io.StringIO()
    stderr = io.StringIO()
    return_code = execution_utils.Exec(
        self._args, no_exit=True, in_str=self._stdin, out_func=stdout.write,
        err_func=stderr.write)

    action_location = updates.Context(
        self._original_data, None, None).Location()
    try:
      with assertions.FailureCollector(
          scenario_context.update_modes, spec_name=scenario_context.spec_name,
          action_location=action_location,
          execution_mode=scenario_context.execution_mode.name) as failures:
        failures.AddAll(exit_event.HandleReturnCode(return_code))
        failures.AddAll(stdout_event.Handle(stdout.getvalue()))
        failures.AddAll(stderr_event.Handle(stderr.getvalue()))
    finally:
      if scenario_context.update_modes:
        scenario_context.RewriteScenario()


class ExecuteCommandAction(Action):
  """Action that runs a command and validates assertions about its execution."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""
    command_execution_data = data.get('execute_command')
    return cls(
        command_execution_data['command'],
        command_execution_data.get('track'),
        command_execution_data.get('cleanup_for'),
        command_execution_data.get('validation_only'),
        command_execution_data.get('validate_remote_api_calls', True),
        command_execution_data.get('label'),
        command_execution_data,
    )

  def __init__(self, command, track, cleanup_for, validation_only,
               validate_remote_api_calls, label, original_event_data):
    super(ExecuteCommandAction, self).__init__()
    self.command = command
    self.track = calliope_base.ReleaseTrack.FromId(track) if track else None
    self.cleanup_for = cleanup_for
    self.validation_only = validation_only
    self.validate_remote_api_calls = validate_remote_api_calls
    self.label = label
    self._original_data = original_event_data

  def _LoadEvents(self, resource_ref_resolver):
    """A generator that yields events as they are needed.

    It is important to only load events immediately before use because resource
    references are resolved when events are loaded. Resource references that are
    extracted from previous events need to be made available for substitution
    in subsequent events.

    Args:
      resource_ref_resolver: ResourceReferenceResolver, The resolver that
        tracks the references.

    Raises:
      ValueError: If an unknown event type is encountered.

    Yields:
      The events in the command execution action.
    """
    for e in self._original_data.get('events') or []:
      if resource_ref_resolver:
        e = resource_ref_resolver.Resolve(e)
      if 'api_call' in e:
        yield events.ApiCallEvent.FromData(e)
      elif 'expect_stdout' in e:
        yield events.StdoutEvent.FromData(e)
      elif 'expect_stderr' in e:
        yield events.StderrEvent.FromData(e)
      elif 'expect_file_written' in e:
        yield events.FileWrittenEvent.FromData(e)
      elif 'user_input' in e:
        yield events.UserInputEvent.FromData(e)
      elif 'expect_exit' in e:
        yield events.ExitEvent.FromData(e)
      elif 'expect_progress_bar' in e:
        yield events.ProgressBarEvent.FromData(e)
      elif 'expect_progress_tracker' in e:
        yield events.ProgressTrackerEvent.FromData(e)
      elif 'expect_staged_progress_tracker' in e:
        yield events.StagedProgressTrackerEvent.FromData(e)
      elif 'expect_prompt_continue' in e:
        yield events.PromptContinueEvent.FromData(e)
      elif 'expect_prompt_choice' in e:
        yield events.PromptChoiceEvent.FromData(e)
      elif 'expect_prompt_response' in e:
        yield events.PromptResponseEvent.FromData(e)
      else:
        # This will never happen if schema passes validation.
        raise ValueError('Unknown event type: {}'.format(e))

  def Summary(self):
    if self.track:
      command = [self.track.prefix, self.command]
    else:
      command = [self.command]
    steps = [{'command': ' '.join(command)}]
    if self.label:
      steps.insert(0, {'label': self.label})
    for e in self._LoadEvents(None):
      steps.extend(e.Summary())
    return [{'execute': steps}]

  def Execute(self, scenario_context):

    if scenario_context.execution_mode == session.ExecutionMode.LOCAL:
      if self.validation_only:
        # If this command is only used to validate the side effects of a
        # previous command, don't bother running it in LOCAL mode since
        # everything is fake anyway.
        return
      ignore_api_calls = False
    else:
      # In remote mode, ignore api_call validation if this is a validation only
      # command or if api_call validation is explicitly disabled.
      ignore_api_calls = (self.validation_only or
                          not self.validate_remote_api_calls)

    update_modes = scenario_context.update_modes
    stream_mocker = scenario_context.stream_mocker
    action_location = updates.Context(
        self._original_data, None, None).Location()

    session_obj = None
    try:
      with assertions.FailureCollector(
          update_modes, spec_name=scenario_context.spec_name,
          action_location=action_location,
          execution_mode=scenario_context.execution_mode.name) as failures:
        with session.Session(
            self._LoadEvents(scenario_context.resource_ref_resolver),
            failures, stream_mocker, scenario_context.execution_mode,
            ignore_api_calls, scenario_context.resource_ref_resolver,
            action_location=action_location, debug=scenario_context.debug) as s:
          session_obj = s
          scenario_context.command_executor(
              scenario_context.resource_ref_resolver.Resolve(self.command),
              track=self.track)
    finally:
      if session_obj:
        if update_modes:
          # Update spec file
          event_data = session_obj.GetEventSequence()
          if event_data is not None:
            self._SetEventData(scenario_context, event_data)
      # If this is a cleanup step, remove the resource ref so it can no longer
      # be used and we know it doesn't require further cleanup.
      if self.cleanup_for:
        scenario_context.resource_ref_resolver.RemoveGeneratedResourceId(
            self.cleanup_for)

    remaining_stdin = sys.stdin.read()
    if remaining_stdin:
      raise Error('Not all stdin was consumed: [{}]'.format(remaining_stdin))

  def ExecuteCleanup(self, scenario_context):
    # TODO(b/112041463): Make cleanup more robust.
    if not self.cleanup_for:
      return
    if (self.cleanup_for in
        scenario_context.resource_ref_resolver.UncleanedReferences()):
      try:
        self.Execute(scenario_context)
      except Exception as e:  # pylint: disable=broad-except, Best effort
        if isinstance(e, (KeyboardInterrupt, SystemExit)):
          raise
        log.error('Cleanup step failed: {}'.format(e))

  def _SetEventData(self, scenario_context, new_event_data):
    # Searches the event data for resource ids that we know about and replaces
    # them with their equivalent reference (ex $$instance$$). Next time the
    # test is run, these ids will correctly be resolved to whatever the new id
    # should be.
    new_event_data = scenario_context.resource_ref_resolver.ReverseResolve(
        new_event_data)
    event_data = []
    for e in new_event_data:
      if not e:
        continue
      # For generated ids, we get a new id for each test run and we want to
      # substitute that throughout the test (this is why we do the reverse
      # resolve above). Extracted ids are a bit of a special case because we
      # don't generate them, the API does (ex. operations). We want them to be
      # reverse resolved everywhere except for the saved API response data
      # (since this is where the id comes from). In local mode, the real id that
      # the API returned last time will be in the data and used. In remote mode,
      # a real id will be returned and the fact that the response has an ID from
      # another run doesn't matter because it is not used.
      response_data = e.get('api_call', {}).get('return_response', {})
      if response_data:
        scenario_context.resource_ref_resolver.Resolve(response_data,
                                                       extracted_only=True)
      event_data.append(e)

    self._original_data['events'] = event_data
    scenario_context.RewriteScenario()


class Validator(object):
  """Validates an individual scenario instance."""

  def __init__(self, test_data):
    self.schema = yaml.load(pkg_resources.GetResourceFromFile(
        _SCENARIO_SCHEMA_PATH))
    self.test_data = test_data

  def _Write(self, msg):
    sys.__stderr__.write(msg)

  def ValidateSchema(self):
    """Validate scenario against scenario language schema."""
    try:
      jsonschema.validate(self.test_data, self.schema)
      return True
    except jsonschema.exceptions.ValidationError as ve:
      msg = io.StringIO()
      msg.write('ERROR: Schema validation failed: {}\n\n'.format(ve))

      if ve.cause:
        additional_exception = 'Root Exception: {}'.format(ve.cause)
      else:
        additional_exception = ''

      root_error = ve.context[-1] if ve.context else None
      if root_error:
        error_path = ''.join(
            ('[{}]'.format(elem) for elem in root_error.absolute_path))
      else:
        error_path = ''

      msg.write(
          'Additional Details:\n'
          'Error Message: {msg}\n\n'
          'Failing Validation Schema: {schema}\n\n'
          'Failing Element: {instance}\n\n'
          'Failing Element Path: {path}\n\n'
          '{additional_cause}\n'.format(
              msg=root_error.message if root_error else None,
              instance=root_error.instance if root_error else None,
              schema=root_error.schema if root_error else None,
              path=error_path,
              additional_cause=additional_exception))
      raise ValidationError(msg.getvalue())

  def ValidateCleanup(self):
    """Validate that generated resource references have cleanups."""
    success = True
    references = {}
    actions = self.test_data.get('actions', [])

    msg = io.StringIO()

    for a in actions:
      if 'generate_resource_id' in a:
        # pylint: disable=protected-access
        id_action = GenerateResourceIdAction.FromData(a)
        if id_action._reference in references:
          msg.write('Duplicate generate_resource_id reference found: [{}]\n'
                    .format(id_action._reference))
          success = False
        else:
          references[id_action._reference] = id_action._requires_cleanup

    cleanups = set()
    for a in actions:
      execute_action = a.get('execute_command')
      if execute_action:
        ref = execute_action.get('cleanup_for')
        if ref:
          if ref in cleanups:
            msg.write('Duplicate cleanup_for reference found: [{}]\n'
                      .format(ref))
            success = False
            continue
          else:
            cleanups.add(ref)

          if ref not in references:
            msg.write('cleanup_for reference [{}] was not found in a '
                      'generate_resource_id action\n'.format(ref))
            success = False
          requires_cleanup = references.get(ref)
          if not requires_cleanup:
            msg.write('cleanup_for reference [{}] was marked as not requiring '
                      'cleanup\n'.format(ref))
            success = False
          else:
            del references[ref]

    for ref, requires_cleanup in sorted(references.items()):
      if requires_cleanup:
        msg.write('No cleanup_for rules found for generate_resource_id action: '
                  '[{}]\n'.format(ref))
        success = False

    if not success:
      raise ValidationError(msg.getvalue())

  def Validate(self):
    self.ValidateSchema()
    self.ValidateCleanup()
