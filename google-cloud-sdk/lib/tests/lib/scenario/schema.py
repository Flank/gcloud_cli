# -*- coding: utf-8 -*- #
# Copyright 2017 Google Inc. All Rights Reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

"""Parses the scenario yaml test file."""

from __future__ import absolute_import
from __future__ import division
from __future__ import unicode_literals

import abc
import io
import os
import re
import shutil
import sys

from googlecloudsdk.core import log
from googlecloudsdk.core import properties
from googlecloudsdk.core import yaml
from googlecloudsdk.core.util import files
from googlecloudsdk.core.util import pkg_resources
from tests.lib import e2e_utils
from tests.lib import sdk_test_base
from tests.lib.scenario import assertions
from tests.lib.scenario import events
from tests.lib.scenario import session
from tests.lib.scenario import updates

import jsonschema
import six


_SCENARIO_SCHEMA_FILE_NAME = 'scenario_schema.yaml'
_SCENARIO_SCHEMA_PATH = (os.path.join(os.path.dirname(__file__),
                                      _SCENARIO_SCHEMA_FILE_NAME))


class Error(Exception):
  """Base exception for the module."""
  pass


class ScenarioContext(object):
  """A holder for things from a test_base that the scenario needs to run.

  Attributes:
    spec_name: str, A human friendly name that clearly indicates what scenario
      is being operated on.
    full_spec_path: str, The absolute path to the file that the spec was loaded
      from.
    spec_data: The parsed spec data.
    update_modes: [updates.Mode], The list of enabled update modes for this
      scenario run.
    stream_mocker: session.StreamMocker, The holder for mock streams to event
      handling.
    command_executor: f([str]), The function to call to execute a command.
    resource_ref_resolver: ResourceReferenceResolver, The resolver used to
      resolve resource references in the scenario file (ex. $$my-instance$$)
      with the actual resource ID generated by a generate_resource_id action.
  """

  def __init__(self, spec_name, full_spec_path, spec_data, execution_mode,
               update_modes, stream_mocker, command_executor):
    self.spec_name = spec_name
    self.full_spec_path = full_spec_path
    self.spec_data = spec_data
    self.execution_mode = execution_mode
    self.update_modes = update_modes
    self.stream_mocker = stream_mocker
    self.command_executor = command_executor
    self.resource_ref_resolver = ResourceReferenceResolver()


class ResourceReferenceResolver(object):
  """Tracks and resolves generated and extracted resource references.

  For REMOTE tests, we cannot use hardcoded names for resources because they
  will collide. The generate_resource_id action allows you to generate a unique
  resource id for a given test run and name it with an alias that you use to
  refer to it in your scenario file. This class keeps track of the mappings
  of reference to generated id.

  The extract_references directive in the expect_response section of an api_call
  allows you to capture a generated resource id (like an operation) that you
  need to use later. This class also tracks those references so they can be
  resolved.
  """

  def __init__(self):
    self._resource_ids = {}
    self._extracted_ids = {}

  def SetExtractedId(self, reference, resource_id):
    self._extracted_ids[reference] = resource_id

  def IsExtractedIdCurrent(self, reference, resource_id):
    return self._extracted_ids.get(reference) == resource_id

  def AddGeneratedResourceId(self, reference, resource_id):
    self._resource_ids[reference] = resource_id

  def RemoveGeneratedResourceId(self, reference):
    del self._resource_ids[reference]

  def UncleanedReferences(self):
    return self._resource_ids

  def Resolve(self, data, extracted_only=False):
    """Recursively resolves resource references in the given data.

    Args:
      data: The data structure you want to recursively resolve references in.
      extracted_only: bool, If true, only extracted references will be resolved
        (not generated references).

    Raises:
      ValueError: If a reference cannot be resolved.

    Returns:
      The original data structure with references resolved.
    """
    if data is None:
      pass
    elif isinstance(data, six.string_types):
      refs = re.findall(r'\$\$([-\w_]+)\$\$', data)
      for r in refs:
        resource_id = self._resource_ids.get(r) or self._extracted_ids.get(r)
        if not resource_id:
          raise ValueError('Unknown resource reference: [{}]'.format(r))
        if extracted_only and r not in self._extracted_ids:
          continue
        data = data.replace('$$' + r + '$$', resource_id)
    # We intentionally replace the data in-place here so that the same data
    # structure can be written back out to the scenario file.
    elif isinstance(data, list):
      for x in range(len(data)):
        data[x] = self.Resolve(data[x], extracted_only=extracted_only)
    elif isinstance(data, dict):
      for k in data:
        data[k] = self.Resolve(data[k], extracted_only=extracted_only)
    # Things like ints, bools, etc. that don't need processing fall through.
    return data

  def ReverseResolve(self, data):
    """Recursively reverse resolves resource references in the given data."""
    if data is None:
      pass
    elif isinstance(data, six.string_types):
      for ids in [self._resource_ids, self._extracted_ids]:
        for reference, resource_id in six.iteritems(ids):
          data = data.replace(resource_id, '$$' + reference + '$$')
    elif isinstance(data, list):
      for x in range(len(data)):
        data[x] = self.ReverseResolve(data[x])
    elif isinstance(data, dict):
      for k in data:
        data[k] = self.ReverseResolve(data[k])
    # Things like ints, bools, etc. that don't need processing fall through.
    return data


class Scenario(object):
  """Holds the entire scenario spec."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""

    skip_data = data.get('skip')
    skip = (skip_data.get('reason'),
            skip_data.get('bug')) if skip_data else None
    return cls(
        title=data.get('title'),
        description=data.get('description'),
        skip=skip,
        data=data)

  def __init__(self, title, description, skip, data):
    self.title = title
    self.description = description
    self.skip = skip
    self._data = data

  def LoadActions(self):
    """A generator that loads each action in the scenario when needed."""
    for a in self._data.get('actions') or []:
      if 'set_property' in a:
        yield SetPropertyAction.FromData(a)
      elif 'write_file' in a:
        yield WriteFileAction.FromData(a)
      elif 'load_resource' in a:
        yield LoadResourceAction.FromData(a)
      elif 'generate_resource_id' in a:
        yield GenerateResourceIdAction.FromData(a)
      elif 'execute_command' in a:
        yield CommandExecutionAction.FromData(a)
      else:
        # This will never happen if schema passes validation.
        raise ValueError('Unknown action type: {}'.format(a))


class Action(six.with_metaclass(abc.ABCMeta, object)):
  """Base class for all actions."""

  @abc.abstractmethod
  def Execute(self, scenario_context):
    pass

  def ExecuteCleanup(self, scenario_context):
    return None


class SetPropertyAction(Action):
  """Action that sets properties."""

  @classmethod
  def FromData(cls, data):
    return cls(data.get('set_property', {}))

  def __init__(self, props):
    self.properties = props

  def Execute(self, scenario_context):
    del scenario_context
    for p, v in six.iteritems(self.properties):
      properties.FromString(p).Set(v)


class WriteFileAction(Action):
  """Action that writes a file for use in tests."""

  @classmethod
  def FromData(cls, data):
    write_file_data = data['write_file']
    path = write_file_data['path']
    contents = write_file_data.get('contents')
    binary_contents = write_file_data.get('binary_contents')
    if (binary_contents is not None and
        isinstance(binary_contents, six.text_type)):
      binary_contents = binary_contents.encode('utf8')

    return cls(path, contents, binary_contents)

  def __init__(self, path, contents, binary_contents):
    self._path = path
    self._contents = contents
    self._binary_contents = binary_contents

  def Execute(self, scenario_context):
    del scenario_context
    full_path = os.path.join(os.getcwd(), self._path)
    files.MakeDir(os.path.dirname(full_path))
    if self._binary_contents:
      files.WriteBinaryFileContents(full_path, self._binary_contents)
    else:
      files.WriteFileContents(full_path, self._contents)


class LoadResourceAction(Action):
  """Loads a resource from text data into the CWD for use in a test."""

  @classmethod
  def FromData(cls, data):
    path = data['load_resource']['path']
    return cls(path)

  def __init__(self, path):
    self._path = path

  def Execute(self, scenario_context):
    del scenario_context
    resource_path = sdk_test_base.SdkBase.Resource(*self._path.split('/'))
    dest_path = os.path.join(os.getcwd(), os.path.basename(resource_path))
    if os.path.isdir(resource_path):
      files.CopyTree(resource_path, dest_path)
    else:
      shutil.copy(resource_path, dest_path)


class GenerateResourceIdAction(Action):
  """Action that generates a unique resource id for use in an e2e test."""

  @classmethod
  def FromData(cls, data):
    action_data = data['generate_resource_id']
    return cls(action_data['reference'], action_data['prefix'])

  def __init__(self, reference, prefix):
    self._reference = reference
    self._prefix = prefix

  def Execute(self, scenario_context):
    scenario_context.resource_ref_resolver.AddGeneratedResourceId(
        self._reference,
        next(e2e_utils.GetResourceNameGenerator(prefix=self._prefix)))


class CommandExecutionAction(Action):
  """Action that runs a command and validates assertions about its execution."""

  @classmethod
  def FromData(cls, data):
    """Build the object from spec data."""
    command_execution_data = data.get('execute_command')
    return cls(
        command_execution_data['command'],
        command_execution_data.get('cleanup_for'),
        command_execution_data,
    )

  def __init__(self, command, cleanup_for, original_event_data):
    self.command = command
    self.cleanup_for = cleanup_for
    self._original_data = original_event_data

  def _LoadEvents(self, resource_ref_resolver):
    """A generator that yields events as they are needed.

    It is important to only load events immediately before use because resource
    references are resolved when events are loaded. Resource references that are
    extracted from previous events need to be made available for substitution
    in subsequent events.

    Args:
      resource_ref_resolver: ResourceReferenceResolver, The resolver that
        tracks the references.

    Raises:
      ValueError: If an unknown event type is encountered.

    Yields:
      The events in the command execution action.
    """
    for e in self._original_data.get('events') or []:
      e = resource_ref_resolver.Resolve(e)
      if 'api_call' in e:
        yield events.ApiCallEvent.FromData(e)
      elif 'expect_stdout' in e:
        yield events.StdoutEvent.FromData(e)
      elif 'expect_stderr' in e:
        yield events.StderrEvent.FromData(e)
      elif 'expect_file_written' in e:
        yield events.FileWrittenEvent.FromData(e)
      elif 'user_input' in e:
        yield events.UserInputEvent.FromData(e)
      elif 'expect_exit' in e:
        yield events.ExitEvent.FromData(e)
      elif 'expect_progress_bar' in e:
        yield events.ProgressBarEvent.FromData(e)
      elif 'expect_progress_tracker' in e:
        yield events.ProgressTrackerEvent.FromData(e)
      elif 'expect_prompt_continue' in e:
        yield events.PromptContinueEvent.FromData(e)
      elif 'expect_prompt_choice' in e:
        yield events.PromptChoiceEvent.FromData(e)
      else:
        # This will never happen if schema passes validation.
        raise ValueError('Unknown event type: {}'.format(e))

  def Execute(self, scenario_context):
    update_modes = scenario_context.update_modes
    stream_mocker = scenario_context.stream_mocker
    action_location = updates.Context(
        self._original_data, None, None).Location()

    session_obj = None
    try:
      with assertions.FailureCollector(
          update_modes, spec_name=scenario_context.spec_name,
          action_location=action_location) as failures:
        with session.Session(
            self._LoadEvents(scenario_context.resource_ref_resolver),
            failures, stream_mocker, scenario_context.execution_mode,
            scenario_context.resource_ref_resolver,
            action_location=action_location) as s:
          session_obj = s
          scenario_context.command_executor(
              scenario_context.resource_ref_resolver.Resolve(self.command))
    finally:
      if session_obj:
        if update_modes:
          # Update spec file
          event_data = session_obj.GetEventSequence()
          if event_data is not None:
            self._SetEventData(scenario_context, event_data)
      # If this is a cleanup step, remove the resource ref so it can no longer
      # be used and we know it doesn't require further cleanup.
      if self.cleanup_for:
        scenario_context.resource_ref_resolver.RemoveGeneratedResourceId(
            self.cleanup_for)

    remaining_stdin = sys.stdin.read()
    if remaining_stdin:
      raise Error('Not all stdin was consumed: [{}]'.format(remaining_stdin))

  def ExecuteCleanup(self, scenario_context):
    # TODO(b/112041463): Make cleanup more robust.
    if not self.cleanup_for:
      return
    if (self.cleanup_for in
        scenario_context.resource_ref_resolver.UncleanedReferences()):
      try:
        self.Execute(scenario_context)
      except Exception as e:  # pylint: disable=broad-except, Best effort
        log.error('Cleanup step failed: {}'.format(e))

  def _SetEventData(self, scenario_context, new_event_data):
    # Searches the event data for resource ids that we know about and replaces
    # them with their equivalent reference (ex $$instance$$). Next time the
    # test is run, these ids will correctly be resolved to whatever the new id
    # should be.
    new_event_data = scenario_context.resource_ref_resolver.ReverseResolve(
        new_event_data)
    event_data = []
    for e in new_event_data:
      if not e:
        continue
      # For generated ids, we get a new id for each test run and we want to
      # substitute that throughout the test (this is why we do the reverse
      # resolve above). Extracted ids are a bit of a special case because we
      # don't generate them, the API does (ex. operations). We want them to be
      # reverse resolved everywhere except for the saved API response data
      # (since this is where the id comes from). In local mode, the real that
      # the API returned last time will be in the data and used. In remote mode,
      # a real id will be returned and the fact that the response has an ID from
      # another run doesn't matter because it is not used.
      response_data = e.get('api_call', {}).get('return_response', {})
      if response_data:
        scenario_context.resource_ref_resolver.Resolve(response_data,
                                                       extracted_only=True)
      event_data.append(e)

    self._original_data['events'] = event_data
    self._RewriteScenario(scenario_context)

  def _RewriteScenario(self, scenario_context):
    with io.open(scenario_context.full_spec_path, 'wt') as f:
      yaml.dump(scenario_context.spec_data, f, round_trip=True)


class Validator(object):
  """Validates an individual scenario instance."""

  def __init__(self, test_data):
    self.schema = yaml.load(pkg_resources.GetResourceFromFile(
        _SCENARIO_SCHEMA_PATH))
    self.test_data = test_data

  def _Write(self, msg):
    sys.__stderr__.write(msg)

  def ValidateSchema(self):
    """Validate scenario against scenario language schema."""
    try:
      jsonschema.validate(self.test_data, self.schema)
      return True
    except jsonschema.exceptions.ValidationError as ve:
      self._Write('ERROR: Schema validation failed: {}\n\n'.format(ve))

      if ve.cause:
        additional_exception = 'Root Exception: {}'.format(ve.cause)
      else:
        additional_exception = ''

      root_error = ve.context[-1] if ve.context else None
      if root_error:
        error_path = ''.join(
            ('[{}]'.format(elem) for elem in root_error.absolute_path))
      else:
        error_path = ''

      self._Write(
          'Additional Details:\n'
          'Error Message: {msg}\n\n'
          'Failing Validation Schema: {schema}\n\n'
          'Failing Element: {instance}\n\n'
          'Failing Element Path: {path}\n\n'
          '{additional_cause}\n'.format(
              msg=root_error.message if root_error else None,
              instance=root_error.instance if root_error else None,
              schema=root_error.schema if root_error else None,
              path=error_path,
              additional_cause=additional_exception))
      return False

  def ValidateCleanup(self):
    """Validate that generated resource references have cleanups."""
    success = True
    references = set()
    actions = self.test_data.get('actions', [])

    for a in actions:
      id_action = a.get('generate_resource_id')
      if id_action:
        ref = id_action['reference']
        if ref in references:
          self._Write('Duplicate generate_resource_id reference found: [{}]\n'
                      .format(ref))
          success = False
        else:
          references.add(ref)

    cleanups = set()
    for a in actions:
      execute_action = a.get('execute_command')
      if execute_action:
        ref = execute_action.get('cleanup_for')
        if ref:
          if ref in cleanups:
            self._Write('Duplicate cleanup_for reference found: [{}]\n'
                        .format(ref))
            success = False
            continue
          else:
            cleanups.add(ref)

          if ref not in references:
            self._Write('cleanup_for reference [{}] was not found in a '
                        'generate_resource_id action\n'.format(ref))
            success = False
          else:
            references.remove(ref)

    if references:
      self._Write('No cleanup_for rules found for generate_resource_id action: '
                  '[{}]\n'.format(', '.join(sorted(references))))
      success = False

    return success

  def Validate(self):
    if not self.ValidateSchema():
      return False
    if not self.ValidateCleanup():
      return False
    return True
